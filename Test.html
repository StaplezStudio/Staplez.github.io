<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Viewer with Link</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; height: 100vh; font-family: sans-serif; background-color: #222; color: #eee; }
        #controls { padding: 10px; background-color: #333; display: flex; justify-content: center; align-items: center; gap: 10px; }
        #modelURL { flex-grow: 1; padding: 8px; border: 1px solid #555; border-radius: 4px; background-color: #444; color: #eee; max-width: 600px; }
        #loadButton { padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #loadButton:hover { background-color: #0056b3; }
        #info { margin-left: 20px; font-size: 0.9em; }
        #viewer-container { flex-grow: 1; width: 100%; display: flex; justify-content: center; align-items: center; background-color: #111; }
        canvas { display: block; }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 100;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="modelURL">GLB Model URL:</label>
        <input type="text" id="modelURL" placeholder="e.g., https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb">
        <button id="loadButton">Load Model</button>
        <div id="info">
            <p>Drag and rotate with mouse. Scroll to zoom.</p>
        </div>
    </div>

    <div id="viewer-container">
        <div id="loading-overlay">Loading Model...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, model, controls;
        const viewerContainer = document.getElementById('viewer-container');
        const loadingOverlay = document.getElementById('loading-overlay');
        const modelURLInput = document.getElementById('modelURL');
        const loadButton = document.getElementById('loadButton');

        // Set a default model URL
        modelURLInput.value = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // Dark background

            // Camera
            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1, 3); // Adjust initial camera position

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            viewerContainer.appendChild(renderer.domElement);

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // For a smoother experience
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Prevents panning beyond limits
            controls.minDistance = 0.5; // Minimum zoom
            controls.maxDistance = 10; // Maximum zoom
            controls.target.set(0, 0.5, 0); // Focus on the center of the scene

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Soft ambient light
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 5, 5).normalize();
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-5, 5, -5).normalize();
            scene.add(directionalLight2);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function onWindowResize() {
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
            renderer.render(scene, camera);
        }

        function loadModel(url) {
            if (!url) {
                alert('Please enter a GLB model URL.');
                return;
            }

            loadingOverlay.style.display = 'flex'; // Show loading overlay

            // Remove existing model if any
            if (model) {
                scene.remove(model);
                model.traverse(object => {
                    if (object.isMesh) {
                        object.geometry.dispose();
                        if (object.material.isMaterial) {
                            cleanMaterial(object.material);
                        } else {
                            // An array of materials
                            for (const material of object.material) cleanMaterial(material);
                        }
                    }
                });
                model = null;
            }

            const loader = new GLTFLoader();
            loader.load(
                url,
                function (gltf) {
                    model = gltf.scene;
                    scene.add(model);

                    // Fit model to view
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    // Adjust camera to fit the model
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 1.5; // Add some padding

                    camera.position.set(center.x, center.y, center.z + cameraZ);
                    controls.target.copy(center);
                    controls.update();

                    loadingOverlay.style.display = 'none'; // Hide loading overlay
                },
                // called while loading is progressing
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    loadingOverlay.innerHTML = `Loading Model... ${Math.round(xhr.loaded / xhr.total * 100)}%`;
                },
                // called when loading has errors
                function (error) {
                    console.error('An error happened', error);
                    alert('Failed to load model. Check the URL and console for errors. CORS issues might prevent loading from some servers.');
                    loadingOverlay.style.display = 'none'; // Hide loading overlay
                    loadingOverlay.innerHTML = `Loading Model...`; // Reset text
                }
            );
        }

        function cleanMaterial(material) {
            material.dispose();
            // Dispose textures
            for (const key of Object.keys(material)) {
                const value = material[key];
                if (value && typeof value === 'object' && 'minFilter' in value) {
                    value.dispose();
                }
            }
        }

        // Event listeners
        loadButton.addEventListener('click', () => loadModel(modelURLInput.value));
        modelURLInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                loadModel(modelURLInput.value);
            }
        });

        // Initialize the viewer
        init();
        // Load the default model on page load
        loadModel(modelURLInput.value);
    </script>
</body>
</html>

